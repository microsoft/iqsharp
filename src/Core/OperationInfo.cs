// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Quantum.IQSharp.Common;
using Microsoft.Quantum.QsCompiler;
using Microsoft.Quantum.Simulation.Core;

using Newtonsoft.Json;

namespace Microsoft.Quantum.IQSharp
{
    /// <summary>
    /// Represents information about a Q# operation. 
    /// The operation is extracted from a Roslyn Type, which is expected to be a 
    /// code-generated class coming from the Q# code generation
    /// library.
    /// Specifically, it extracts information from the static "Run" method
    /// that is auto-generated by the Q# code generation library.
    /// </summary>
    public class OperationInfo
    {
        private Lazy<Dictionary<string, string>> _params;
        private Lazy<ParameterInfo[]> _roslynParams;
        private Lazy<Type> _returnType;

        internal OperationInfo(Type? roslynType, CallableDeclarationHeader header)
        {
            this.Header = header ?? throw new ArgumentNullException(nameof(header));
            RoslynType = roslynType;
            var runMethod = new Lazy<MethodInfo>(() =>
                RoslynType?.GetMethod("Run") is {} method
                ? method
                : throw new Exception($"Roslyn type {roslynType} generated for a Q# operation does not exist or does not have a Run method.")
            );
            _roslynParams = new Lazy<ParameterInfo[]>(() => runMethod.Value.GetParameters().Skip(1).ToArray());
            _returnType = new Lazy<Type>(() => runMethod.Value.ReturnType.GenericTypeArguments.Single());
            _params = new Lazy<Dictionary<string, string>>(() => RoslynParameters.ToDictionary(
                p => p.Name is string name ? name : throw new Exception($"Roslyn parameter {p} did not have a name."),
                p => p.ParameterType.Name
            ));
        }

        public string FullName => Header.QualifiedName.ToFullName().WithoutNamespace(Snippets.SNIPPETS_NAMESPACE);

        /// <summary>
        ///     The header containing all callable declaration metadata as
        ///     serialized in the assembly containing this operation.
        /// </summary>
        /// <remarks>
        ///     The data structure for this property is defined by the Q#
        ///     compiler itself, and is not specific to the IQ# kernel or
        ///     service.
        /// </remarks>
        public CallableDeclarationHeader Header { get; }

        /// <summary>
        /// The underlying compiled .NET Type for this Q# operation
        /// </summary>
        [JsonIgnore]
        public Type? RoslynType { get; }

        /// <summary>
        /// The input parameters for the underlying compiled .NET Type for this Q# operation
        /// </summary>
        [JsonIgnore]
        public ParameterInfo[] RoslynParameters => _roslynParams.Value;

        /// <summary>
        /// The return type for the underlying compiled .NET Type for this Q# operation
        /// </summary>
        [JsonIgnore]
        public Type ReturnType => _returnType.Value;

        public override string ToString() => FullName;
    }

    /// <summary>
    /// Extension methods for OperationInfo. This allows to keep OperationInfo as a pure
    /// data structure but still expose things like RunAsync.
    /// </summary>
    public static class OperationInfoExtensions
    {
        public static async Task<object> RunAsync(this OperationInfo op, IOperationFactory qsim, IDictionary<string, string>? arguments = null)
        {
            if (op.RoslynType == null) throw new InvalidOperationException($"Operation {op.FullName} can't be executed.");

            var run = op.RoslynType.GetMethod("Run");
            Debug.Assert(run != null, $"C# class code-generated by the Q# compiler missing a Run method for operation {op.FullName}.");
            var args = op.GetRunArguments(qsim, arguments);
            // We know that Run methods generated by the Q# compiler's C#
            // code generation step never have a void return type, and in
            // particular never return null. Thus, we can use null-forgiveness
            // here to communicate that to the C# compiler.
            return await (dynamic)run.Invoke(null, args)!;
        }

        private static object[] GetRunArguments(this OperationInfo op, IOperationFactory qsim, IDictionary<string, string>? arguments = null)
        {
            var invalid = new List<string>();
            var values = new List<object>();

            values.Add(qsim);
            foreach (var p in op.RoslynParameters)
            {
                if (arguments != null && p.Name is {} name && arguments.TryGetValue(name, out var value))
                {
                    try
                    {
                        values.Add(ParseInputParameter(p.ParameterType, value.ToString()));
                    }
                    catch (Exception e)
                    {
                        invalid.Add($"{p.Name}: {e.Message}");
                    }
                }
                else
                {
                    invalid.Add($"{p.Name}: missing.");
                }
            }

            if (invalid.Count > 0)
            {
                throw new InvalidOperationException($"Received invalid parameters. Please fix and try again:\n {string.Join("\n ", invalid.ToArray())}");
            }

            return values.ToArray();
        }

        private static object ParseInputParameter(Type t, string p)
        {
            if (t == typeof(QVoid))
            {
                return QVoid.Instance;
            }

            var value = Newtonsoft.Json.JsonConvert.DeserializeObject(p, t, JsonConverters.TupleConverters);
            // Input parameters cannot be null, so we need to raise an error
            // here. Since this can be caused by user code, our error needs
            // to not be an assertion failure but something actionable.
            if (value == null)
            {
                throw new JsonSerializationException($"Input parameters for Q# operations cannot be null, but the JSON object `{p}` deserialized to null when attempting to deserialize as type {t}.");
            }
            return value;
        }

    }
}
