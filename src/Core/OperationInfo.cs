// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Quantum.IQSharp.Common;
using Microsoft.Quantum.QsCompiler;
using Microsoft.Quantum.Simulation.Core;

using Newtonsoft.Json;

namespace Microsoft.Quantum.IQSharp
{
    /// <summary>
    /// Represents information about a Q# operation. 
    /// The operation is extracted from a Roslyn Type, which is expected to be a 
    /// code-generated class coming from the Q# code generation
    /// library.
    /// Specifically, it extracts information from the static "Run" method
    /// that is auto-generated by the Q# code generation library.
    /// </summary>
    public class OperationInfo
    {
        private Lazy<Dictionary<string, string>> _params;
        private Lazy<ParameterInfo[]> _roslynParams;

        internal OperationInfo(Type roslynType, CallableDeclarationHeader header)
        {
            this.Header = header ?? throw new ArgumentNullException(nameof(header));
            RoslynType = roslynType;
            _roslynParams = new Lazy<ParameterInfo[]>(() => RoslynType?.GetMethod("Run").GetParameters().Skip(1).ToArray());
            _params = new Lazy<Dictionary<string, string>>(() => RoslynParameters?.ToDictionary(p => p.Name, p => p.ParameterType.Name));
        }

        public string FullName => Header?.QualifiedName?.ToFullName().WithoutNamespace(Snippets.SNIPPETS_NAMESPACE);

        /// <summary>
        ///     The header containing all callable declaration metadata as
        ///     serialized in the assembly containing this operation.
        /// </summary>
        /// <remarks>
        ///     The data structure for this property is defined by the Q#
        ///     compiler itself, and is not specific to the IQ# kernel or
        ///     service.
        /// </remarks>
        public CallableDeclarationHeader Header { get; }

        /// <summary>
        /// The underlying compiled .NET Type for this Q# operation
        /// </summary>
        [JsonIgnore]
        public Type RoslynType { get; }

        /// <summary>
        /// The input parameters for the underlying compiled .NET Type for this Q# operation
        /// </summary>
        [JsonIgnore]
        public ParameterInfo[] RoslynParameters => _roslynParams.Value;

        public override string ToString() => FullName;
    }

    /// <summary>
    /// Extension methods for OperationInfo. This allows to keep OperationInfo as a pure
    /// data structure but still expose things like RunAsync.
    /// </summary>
    public static class OperationInfoExtensions
    {
        public static async Task<object> RunAsync(this OperationInfo op, IOperationFactory qsim, IDictionary<string, string> arguments)
        {
            if (op?.RoslynType == null) throw new InvalidOperationException($"Operation {op?.FullName} can't be executed.");

            var run = op.RoslynType.GetMethod("Run");
            var args = op.GetRunArguments(qsim, arguments);
            return await (dynamic)run.Invoke(null, args);
        }

        private static object[] GetRunArguments(this OperationInfo op, IOperationFactory qsim, IDictionary<string, string> arguments)
        {
            var invalid = new List<string>();
            var values = new List<object>();

            values.Add(qsim);
            foreach (var p in op.RoslynParameters)
            {
                if (arguments != null && arguments.TryGetValue(p.Name, out var value))
                {
                    try
                    {
                        values.Add(ParseInputParameter(p.ParameterType, value?.ToString()));
                    }
                    catch (Exception e)
                    {
                        invalid.Add($"{p.Name}: {e.Message}");
                    }
                }
                else
                {
                    invalid.Add($"{p.Name}: missing.");
                }
            }

            if (invalid.Count > 0)
            {
                throw new InvalidOperationException($"Received invalid parameters. Please fix and try again:\n {string.Join("\n ", invalid.ToArray())}");
            }

            return values.ToArray();
        }

        private static object ParseInputParameter(Type t, string p)
        {
            if (t == typeof(QVoid))
            {
                return QVoid.Instance;
            }

            var value = Newtonsoft.Json.JsonConvert.DeserializeObject(p, t, TupleConverters.Converters);
            return value;
        }

    }
}
